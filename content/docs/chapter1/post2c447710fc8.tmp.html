<div id="selecting-by-row-numbers" class="section level2">
<h2><span class="header-section-number">0.1</span> Selecting by row numbers</h2>
<p>A first way to select the lines you want to work with is to specify a range of line numbers. If selecting the rows is the only operation you want to perform, there is no need to put a comma after the range of numbers. However, including a comma will also work. Personally, I usually keep the comma, because it reminds me that I am working on the part <code>i</code></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" title="1">ans &lt;-<span class="st"> </span>DT[<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, ]</a>
<a class="sourceLine" id="cb1-2" title="2">ans</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">age</th>
<th align="left">city</th>
<th align="left">previous</th>
<th align="right">ans_1</th>
<th align="right">ans_2</th>
<th align="right">ans_3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">43</td>
<td align="left">Cape Town</td>
<td align="left">Pretoria</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">48</td>
<td align="left">Durban</td>
<td align="left">Durban</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">3</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">45</td>
<td align="left">Pretoria</td>
<td align="left">Durban</td>
<td align="right">NA</td>
<td align="right">3</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">40</td>
<td align="left">Cape Town</td>
<td align="left">Pretoria</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
<p>If the rows you want to work with are not in a continuous range, you can declare them in a more precise ways, for example, using the <code>c()</code> command to enumerate the row numbers</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb2-1" title="1">ans &lt;-<span class="st"> </span>DT[<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">7</span>), ]</a>
<a class="sourceLine" id="cb2-2" title="2">ans</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">age</th>
<th align="left">city</th>
<th align="left">previous</th>
<th align="right">ans_1</th>
<th align="right">ans_2</th>
<th align="right">ans_3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">2</td>
<td align="right">48</td>
<td align="left">Durban</td>
<td align="left">Durban</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="right">5</td>
<td align="right">31</td>
<td align="left">Pretoria</td>
<td align="left">Durban</td>
<td align="right">2</td>
<td align="right">2</td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="right">7</td>
<td align="right">35</td>
<td align="left">Durban</td>
<td align="left">Pretoria</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
</div>
<div id="eliminating-some-rows" class="section level2">
<h2><span class="header-section-number">0.2</span> Eliminating some rows</h2>
<p>Sometimes, it will make more sense to eliminate a few rows. To do this, you can put a <code>-</code> sign in front of the range or the selection of rows. Make sure you use parenthesis around the range.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" title="1">ans &lt;-<span class="st"> </span>DT[<span class="op">-</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">5</span>), ]</a>
<a class="sourceLine" id="cb3-2" title="2">ans</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">age</th>
<th align="left">city</th>
<th align="left">previous</th>
<th align="right">ans_1</th>
<th align="right">ans_2</th>
<th align="right">ans_3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">6</td>
<td align="right">40</td>
<td align="left">Cape Town</td>
<td align="left">Pretoria</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="right">7</td>
<td align="right">35</td>
<td align="left">Durban</td>
<td align="left">Pretoria</td>
<td align="right">1</td>
<td align="right">2</td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="right">8</td>
<td align="right">36</td>
<td align="left">Cape Town</td>
<td align="left">Cape Town</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">9</td>
<td align="right">39</td>
<td align="left">Cape Town</td>
<td align="left">Cape Town</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">10</td>
<td align="right">46</td>
<td align="left">Durban</td>
<td align="left">Durban</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="right">11</td>
<td align="right">37</td>
<td align="left">Pretoria</td>
<td align="left">Durban</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="right">12</td>
<td align="right">36</td>
<td align="left">Pretoria</td>
<td align="left">Pretoria</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">13</td>
<td align="right">35</td>
<td align="left">Durban</td>
<td align="left">Durban</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">14</td>
<td align="right">30</td>
<td align="left">Cape Town</td>
<td align="left">Durban</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="right">15</td>
<td align="right">41</td>
<td align="left">Pretoria</td>
<td align="left">Pretoria</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">3</td>
</tr>
</tbody>
</table>
</div>
<div id="taking-a-random-sub-sample-of-rows" class="section level2">
<h2><span class="header-section-number">0.3</span> Taking a random sub-sample of rows</h2>
<p>Sometimes, you just want to take a random sub-sample of your data. To do this, you can take advantage of the function <code>sample()</code> and the function <code>nrow()</code>.</p>
<p>The following command will select three random rows out of the existing 10.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">set.seed</span>(<span class="dv">1234567</span>)</a>
<a class="sourceLine" id="cb4-2" title="2">DT[<span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(DT), <span class="dv">3</span>, <span class="dt">replace=</span><span class="ot">FALSE</span>) , ]</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">age</th>
<th align="left">city</th>
<th align="left">previous</th>
<th align="right">ans_1</th>
<th align="right">ans_2</th>
<th align="right">ans_3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">43</td>
<td align="left">Cape Town</td>
<td align="left">Pretoria</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="right">12</td>
<td align="right">36</td>
<td align="left">Pretoria</td>
<td align="left">Pretoria</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">11</td>
<td align="right">37</td>
<td align="left">Pretoria</td>
<td align="left">Durban</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
<p><em>Note:</em> The command <code>sample(1:nrow(DT), 3, replace=FALSE)</code> will create a vector of three random numbers between 1 and the number of rows. So technically, you are generating a sequence of row numbers that will be used to select the rows to retain.</p>
</div>
<div id="exercise" class="section level2">
<h2><span class="header-section-number">0.4</span> Exercise</h2>
<ul>
<li>Eliminate the rows 2, 5, and 9</li>
<li>Compare the results of DT[c(1,4, 5), ] and DT[c(1,5,4)]</li>
<li>Can you make a random sample of DT that would include 20 rows ?</li>
</ul>
</div>
<div id="selecting-rows-based-on-a-logical-criterion" class="section level2">
<h2><span class="header-section-number">0.5</span> Selecting rows based on a logical criterion</h2>
<p>Let say, you want to look only at the respondents living in Cape Town. To do this, you will include a logical condition in the frame […]. Only rows that corresponds for which the condition is met will be selected.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" title="1">ans &lt;-<span class="st"> </span>DT[city<span class="op">==</span><span class="st">&quot;Cape Town&quot;</span>,]</a>
<a class="sourceLine" id="cb5-2" title="2">ans</a></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">id</th>
<th align="right">age</th>
<th align="left">city</th>
<th align="left">previous</th>
<th align="right">ans_1</th>
<th align="right">ans_2</th>
<th align="right">ans_3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">43</td>
<td align="left">Cape Town</td>
<td align="left">Pretoria</td>
<td align="right">2</td>
<td align="right">3</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td align="right">4</td>
<td align="right">40</td>
<td align="left">Cape Town</td>
<td align="left">Pretoria</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="right">6</td>
<td align="right">40</td>
<td align="left">Cape Town</td>
<td align="left">Pretoria</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="right">8</td>
<td align="right">36</td>
<td align="left">Cape Town</td>
<td align="left">Cape Town</td>
<td align="right">2</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">9</td>
<td align="right">39</td>
<td align="left">Cape Town</td>
<td align="left">Cape Town</td>
<td align="right">3</td>
<td align="right">3</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">14</td>
<td align="right">30</td>
<td align="left">Cape Town</td>
<td align="left">Durban</td>
<td align="right">3</td>
<td align="right">1</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
<p>Note that: + An important feature of <code>data.table</code> is that within the frame of a data.table, columns can be referred to <em>as if they are variables</em>. Therefore, we simply refer to <code>city</code> as if it is a variable. We do not need to add the prefix <code>DT$</code> each time. Nevertheless, using <code>DT$city</code> would work just fine.</p>
<ul>
<li><p>Only the rows that satisfy the condition <code>city=="Cape Town"</code> are selected. Since there is nothing else left to do (the <code>j</code> part is empty), all columns from DT at rows corresponding to those row indices are returned as a data.table.</p></li>
<li><p>A comma after the condition is not required. Again, <code>DT[city=="Cape Town" ]</code> would also work.</p></li>
</ul>
</div>
<div id="exercise-1" class="section level2">
<h2><span class="header-section-number">0.6</span> Exercise</h2>
<ul>
<li>Select respondants from Cape Town whose age is greater or equal to 38</li>
</ul>
</div>
<div id="advanced-topic-using-keys" class="section level2">
<h2><span class="header-section-number">0.7</span> Advanced topic: using keys</h2>
<p>In this section, we will look at another way of subsetting data.tables using keys.</p>
<p>Contrary to data.frames, data.tables never use row names. Instead, in data.tables you can set and use <strong>keys</strong>.</p>
<div id="set-get-and-use-keys-on-a-data.table" class="section level3">
<h3><span class="header-section-number">0.7.1</span> Set, get and use keys on a data.table</h3>
<div id="set-a-column-as-key-in-a-data.table" class="section level4">
<h4><span class="header-section-number">0.7.1.1</span> Set a column as key in a data.table</h4>
<p>To set a key, you can use the function <code>setkey()</code>. The function uses at least two arguments. The first argument is the name of the data.table. The second argument is the name of a column (column names are not quoted).</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">setkey</span>(DT, city) </a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">head</span>(DT)</a></code></pre></div>
<pre><code>##    id age      city  previous ans_1 ans_2 ans_3
## 1:  1  43 Cape Town  Pretoria     2     3     2
## 2:  4  40 Cape Town  Pretoria     3     1     2
## 3:  6  40 Cape Town  Pretoria     3     3     3
## 4:  8  36 Cape Town Cape Town     2     1     1
## 5:  9  39 Cape Town Cape Town     3     3     1
## 6: 14  30 Cape Town    Durban     3     1     2</code></pre>
<p>Note that:</p>
<ul>
<li><p>you did not have to assign the result back to a variable. The function returns the result invisibly.</p></li>
<li><p>The data.table is now sorted by the column we provided - city.</p></li>
</ul>
<p>Once a key is established, you can use the key to subset all rows where the city matches “Pretoria”</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb8-1" title="1">DT[<span class="st">&quot;Pretoria&quot;</span>]  </a></code></pre></div>
<pre><code>##    id age     city previous ans_1 ans_2 ans_3
## 1:  3  45 Pretoria   Durban    NA     3     3
## 2:  5  31 Pretoria   Durban     2     2     2
## 3: 11  37 Pretoria   Durban     2     3     2
## 4: 12  36 Pretoria Pretoria     3     1     1
## 5: 15  41 Pretoria Pretoria     2     3     3</code></pre>
<p>Note that:</p>
<ul>
<li>You enter directly the names of the city you want to subset on. This is because a key exist already.</li>
<li>The main purpose of setting up a key is not to simplify the syntax, but is related to speed. Although you will not see the difference with our very small data.table, the subsetting will be much faster with a key.</li>
</ul>
<p>Indeed, you can enter a vector of city names that you want to subset on:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb10-1" title="1">DT[<span class="kw">c</span>( <span class="st">&quot;Cape Town&quot;</span>, <span class="st">&quot;Pretoria&quot;</span>)]  </a></code></pre></div>
<pre><code>##     id age      city  previous ans_1 ans_2 ans_3
##  1:  1  43 Cape Town  Pretoria     2     3     2
##  2:  4  40 Cape Town  Pretoria     3     1     2
##  3:  6  40 Cape Town  Pretoria     3     3     3
##  4:  8  36 Cape Town Cape Town     2     1     1
##  5:  9  39 Cape Town Cape Town     3     3     1
##  6: 14  30 Cape Town    Durban     3     1     2
##  7:  3  45  Pretoria    Durban    NA     3     3
##  8:  5  31  Pretoria    Durban     2     2     2
##  9: 11  37  Pretoria    Durban     2     3     2
## 10: 12  36  Pretoria  Pretoria     3     1     1
## 11: 15  41  Pretoria  Pretoria     2     3     3</code></pre>
<p>Note:</p>
<ul>
<li>Check the difference between <code>DT[c( "Cape Town", "Pretoria")]</code> and <code>DT[c("Pretoria", "Cape Town")]</code></li>
</ul>
</div>
<div id="set-several-columns-as-key-in-a-data.table" class="section level4">
<h4><span class="header-section-number">0.7.1.2</span> Set several columns as key in a data.table</h4>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">setkey</span>(DT, city, previous)</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="kw">head</span>(DT)</a></code></pre></div>
<pre><code>##    id age      city  previous ans_1 ans_2 ans_3
## 1:  8  36 Cape Town Cape Town     2     1     1
## 2:  9  39 Cape Town Cape Town     3     3     1
## 3: 14  30 Cape Town    Durban     3     1     2
## 4:  1  43 Cape Town  Pretoria     2     3     2
## 5:  4  40 Cape Town  Pretoria     3     1     2
## 6:  6  40 Cape Town  Pretoria     3     3     3</code></pre>
<p>They key will sort the data.table first by the column <code>city</code> and then by <code>previous</code>.</p>
<p>Once the key is established, you can again subset the data.table using the key</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb14-1" title="1">DT[<span class="kw">list</span>(<span class="st">&quot;Durban&quot;</span>, <span class="st">&quot;Pretoria&quot;</span>)]</a></code></pre></div>
<pre><code>##    id age   city previous ans_1 ans_2 ans_3
## 1:  7  35 Durban Pretoria     1     2     2</code></pre>
<p><em>How does this work</em>: “Durban” is first matched against the first key column city. And within those matching rows, “Pretoria” is matched against the second key column <code>previous</code> to obtain row indices where both <code>city</code> and <code>previous</code> match the given values.</p>
<p>Again the main purpose of the key is speed when you have a large data.table.</p>
<p>Note that another way to declare a list within the data.table braces is <code>.( )</code> So you can obtain the same results if you write:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb16-1" title="1">DT[.(<span class="st">&quot;Durban&quot;</span>, <span class="st">&quot;Pretoria&quot;</span>)]</a></code></pre></div>
<pre><code>##    id age   city previous ans_1 ans_2 ans_3
## 1:  7  35 Durban Pretoria     1     2     2</code></pre>
<p>Note that the different columns do not need to be of the same types: city is a string, age is an integer variable.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">setkey</span>(DT, city, ans_<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb18-2" title="2">DT[.(<span class="st">&quot;Durban&quot;</span>, <span class="dv">1</span>)]</a></code></pre></div>
<pre><code>##    id age   city previous ans_1 ans_2 ans_3
## 1:  7  35 Durban Pretoria     1     2     2</code></pre>
<p>Note: Although the key is built upon two columns, you can search on only one colum</p>
<p>When you search on the first column, just mention filter conditions for the first column (do not use commas here)</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">setkey</span>(DT, city, previous)</a>
<a class="sourceLine" id="cb20-2" title="2">DT[.(<span class="st">&quot;Durban&quot;</span>)]</a></code></pre></div>
<pre><code>##    id age   city previous ans_1 ans_2 ans_3
## 1:  2  48 Durban   Durban     3     3     3
## 2: 10  46 Durban   Durban     3     1     2
## 3: 13  35 Durban   Durban     3     3     1
## 4:  7  35 Durban Pretoria     1     2     2</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" title="1">DT[.(<span class="kw">c</span>(<span class="st">&quot;Durban&quot;</span>, <span class="st">&quot;Pretoria&quot;</span>))]</a></code></pre></div>
<pre><code>##    id age     city previous ans_1 ans_2 ans_3
## 1:  2  48   Durban   Durban     3     3     3
## 2: 10  46   Durban   Durban     3     1     2
## 3: 13  35   Durban   Durban     3     3     1
## 4:  7  35   Durban Pretoria     1     2     2
## 5:  3  45 Pretoria   Durban    NA     3     3
## 6:  5  31 Pretoria   Durban     2     2     2
## 7: 11  37 Pretoria   Durban     2     3     2
## 8: 15  41 Pretoria Pretoria     2     3     3
## 9: 12  36 Pretoria Pretoria     3     1     1</code></pre>
<p>When you search on the second column, it is a bit trickier, since you cannot omit the first argument. A way around is then to use the function unique to identify all the cities mentioned in the column <code>city</code>.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" title="1">DT[.(<span class="kw">unique</span>(city), <span class="st">&quot;Durban&quot;</span>)]</a></code></pre></div>
<pre><code>##    id age      city previous ans_1 ans_2 ans_3
## 1: 14  30 Cape Town   Durban     3     1     2
## 2:  2  48    Durban   Durban     3     3     3
## 3: 10  46    Durban   Durban     3     1     2
## 4: 13  35    Durban   Durban     3     3     1
## 5:  3  45  Pretoria   Durban    NA     3     3
## 6:  5  31  Pretoria   Durban     2     2     2
## 7: 11  37  Pretoria   Durban     2     3     2</code></pre>
<p>Not that sometimes, the combinations you are subsetting will not exist in the data.table</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">setkey</span>(DT, city, ans_<span class="dv">1</span>)</a>
<a class="sourceLine" id="cb26-2" title="2">DT[.(<span class="kw">unique</span>(city), <span class="dv">1</span>)]</a></code></pre></div>
<pre><code>##    id age      city previous ans_1 ans_2 ans_3
## 1: NA  NA Cape Town     &lt;NA&gt;     1    NA    NA
## 2:  7  35    Durban Pretoria     1     2     2
## 3: NA  NA  Pretoria     &lt;NA&gt;     1    NA    NA</code></pre>
<p>You can actually choose if queries that do not match should return NA or be skipped altogether using the nomatch argument.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" title="1">DT[.(<span class="kw">unique</span>(city), <span class="dv">1</span>), nomatch=<span class="ot">NULL</span>]</a></code></pre></div>
<pre><code>##    id age   city previous ans_1 ans_2 ans_3
## 1:  7  35 Durban Pretoria     1     2     2</code></pre>
</div>
<div id="what-is-the-current-key" class="section level4">
<h4><span class="header-section-number">0.7.1.3</span> What is the current key?</h4>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">setkey</span>(DT, <span class="st">&quot;city&quot;</span>)</a>
<a class="sourceLine" id="cb30-2" title="2"><span class="kw">key</span>(DT)</a></code></pre></div>
<pre><code>## [1] &quot;city&quot;</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">setkey</span>(DT, <span class="st">&quot;city&quot;</span>, <span class="st">&quot;previous&quot;</span>)</a>
<a class="sourceLine" id="cb32-2" title="2"><span class="kw">key</span>(DT)</a></code></pre></div>
<pre><code>## [1] &quot;city&quot;     &quot;previous&quot;</code></pre>
</div>
<div id="eliminate-a-key" class="section level4">
<h4><span class="header-section-number">0.7.1.4</span> Eliminate a key</h4>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">setkey</span>(DT, <span class="ot">NULL</span>)</a>
<a class="sourceLine" id="cb34-2" title="2"><span class="kw">key</span>(DT)</a></code></pre></div>
<pre><code>## NULL</code></pre>
</div>
</div>
</div>
<div id="advanced-topics-secondary-indices" class="section level2">
<h2><span class="header-section-number">0.8</span> Advanced topics: Secondary indices</h2>
<div id="why-do-we-need-secondary-indices" class="section level3">
<h3><span class="header-section-number">0.8.1</span> Why do we need secondary indices</h3>
<p>When using the <code>setkey()</code> command, behind the scene, you are computing the order vector for the column(s) provided and then you are reordering the entire data.table based on the order vector computed. Although this process has been optimized, this reordering can be expensive (especially with a large number of rows) and not always the best strategy;</p>
<p>In particular, unless your task involves <strong>repeated subsetting on the same column</strong>, fast key based subsetting could effectively be nullified by the time to reorder, depending on your data.table dimensions.</p>
<p>For example, let say you want to subset on <code>city</code> then on <code>previous</code>, then on <code>city</code>, and you want to use keys, you will need to :</p>
<ol style="list-style-type: decimal">
<li>calculate the order vector on city (fast)</li>
<li>reorder the data.table (slow)</li>
<li>subset using city key (super-fast)</li>
<li>calculate the order vector on previous (fast)</li>
<li>reorder the data.table (slow)</li>
<li>subset using previous key (super-fast)</li>
<li>calculate the order vector on city (fast) (you have to do it again, since there is only one key at a time)</li>
<li>reorder the data.table (slow)</li>
<li>subset using city key (super-fast)</li>
</ol>
<p>You can see that having to re-order the vector before subsetting is a wasteful under this scenario.</p>
<p>When the subsetting is not always based on the same column, you are looking for a process that would not have to reorder your data.table everytime you want to subset on a new column, and you might want to keep “orderings” that was already done earlier step (in our case, you may want to keep to ordering vectors one on <code>city</code> and the other one on <code>previous</code> and use them when needed. Under this new scenario, you would:</p>
<ol style="list-style-type: decimal">
<li>calculate the order vector on city (fast)</li>
<li>subset using the ordering on city (fast)</li>
<li>calculate the order vector on previous (fast)</li>
<li>subset using previous key (fast)</li>
<li>subset using city key (fast) …</li>
</ol>
<p>This is what secondary indices are doing.</p>
<p>Secondary indices are similar to keys in data.table, except for two major differences:</p>
<ul>
<li>They only compute the order for the set of columns provided and stores that order vector in an additional attribute called index.</li>
<li>There can be more than one secondary index for a data.table</li>
</ul>
<p>With these two differences, although they might not be as fast as keys in subsetting, your subsetting tasks might be faster when you need subset on different columns at different point of time of your research.</p>
</div>
<div id="creating-secondary-indices" class="section level3">
<h3><span class="header-section-number">0.8.2</span> Creating secondary indices</h3>
<p>First you can create secondary indices using the command <code>setindex()</code>;</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb36-1" title="1"><span class="kw">setindex</span>(DT, previous)</a>
<a class="sourceLine" id="cb36-2" title="2"><span class="kw">head</span>(DT)</a></code></pre></div>
<pre><code>##    id age      city  previous ans_1 ans_2 ans_3
## 1:  8  36 Cape Town Cape Town     2     1     1
## 2:  9  39 Cape Town Cape Town     3     3     1
## 3: 14  30 Cape Town    Durban     3     1     2
## 4:  1  43 Cape Town  Pretoria     2     3     2
## 5:  4  40 Cape Town  Pretoria     3     1     2
## 6:  6  40 Cape Town  Pretoria     3     3     3</code></pre>
</div>
</div>
